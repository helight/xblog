---
title: "云原生技术解读2-云原生运行时和交付部署标准"
date: 2021-11-08T08:45:20+08:00
tags: ["云原生"]
categories: ["云原生", "微服务"]
banner: "img/banners/linux_ebpf_support.png"
author: "helight"
authorlink: "http://helight.info"
summary: ""
keywords: ["云原生", "微服务", "DevOps"]
draft: false
---

## 前言
9 月初给 BG 的新人开了一门课，专门来讲云原生技术，云原生技术从出现到现在按最早的时间出现来说也是有 10 多年了。尤其是这几年火热的不得了，但是 cloud native 这个外文词翻译成中文 “云原生” 就更加的不好理解，再加上本身这个词的定义在发展中又有多次的变化，导致很多学习这块技术的同学都感觉是云里雾里，不知所谓。

所以根据我对这门技术的认识，我开了这门课，一方面我认为我的认识还算比较到位，另一方面我认为目前的新人必须要学习和了解云原生技术，这是目前底层技术发展的大趋势。非常有必要学习和了解，而且我在内部也是致力于推动云原生技术的落地。在推动的过程中也很费劲，很多人看不到这场技术变革的意义和价值，这是非常让人感慨的。

## 云原生技术架构
所以我继续接着上篇解读什么是云原生。这里要接着上面篇文章中的图来继续解释，如下图
![](imgs/4.jpg)
这张图较为清晰的展示了目前云原生架构的基本层次，从最下面的运行时到最上面的应用架构，再辅助于CI/CD的持续思想以及现代变成接口方式：声明式API。层次结构都非常清晰，容易让人理解。所以下面的介绍也是围绕这个图来进行的。

## 运行时技术：容器和容器编排
### 容器技术
容器技术从根本上来说是一种虚拟化技术，如果大家使用过容器就知道，在应用层面上，我们都会认为容器就是一台独立的机器，上篇文章中所说的申请 0.5 核 512M 的资源，让我们感觉就是我们获得了一个 0.5 核 512M 的独立服务器。

但是提到虚拟化技术，这个是由来已久的一个技术了，也是发展了很多年的一个技术，我接触过的就有 vmware，xen，quem，kvm，docker。从发展历史和实现思路上来说虚拟技术可以分为 2 类技术：
> 1. 全虚拟化技术
> 2. 半虚拟化技术

#### 全虚拟化
全虚拟化(FullVirtualization)也称为原始虚拟化技术，该模型使用虚拟机协调Guest操作系统和原始硬件，VMM在Guest操作系统和裸硬件之间用于工作协调，一些受保护指令必须由Hypervisor（虚拟机管理程序）来捕获处理。全虚拟化的运行速度要快于硬件模拟，但是性能方面不如裸机，因为Hypervisor需要占用一些资源。

#### 半虚拟化
半虚拟化(ParaVirtualization)是另一种类似于全虚拟化的技术，它使用Hypervisor分享存取底层的硬件，但是它的Guest操作系统集成了虚拟化方面的代码。该方法无需重新编译或引起陷阱，因为操作系统自身能够与虚拟进程进行很好的协作。半虚拟化需要Guest操作系统做一些修改，使Guest操作系统意识到自己是处于虚拟化环境的，但是半虚拟化提供了与原操作系统相近的性能。

#### 容器虚拟化技术
容器技术是一种相对于虚拟机来说更加轻量的虚拟化技术，能为我们提供一种可移植、可重用的方式来打包、分发和运行应用程序。通过操作系统内核的能力，对每个进程的资源使用(包括CPU、内存、硬盘I/O、网络等)进行隔离，达到容器里运行的进程与其他进程进行一定程度的隔离，同时避免了虚拟机(Virtual Machine)过高的额外消耗。

![](imgs/2.png)

**容器提供的方式是标准化的，可以将不同应用程序的不同组件组装在一起，又可以将它们彼此隔离。**

容器的基本思想就是将需要执行的所有软件打包到一个可执行程序包中，比如将一个Java虚拟机、Tomcat服务器以及应用程序本身打包进一个包中。目前的业界标准把这种包叫做：容器镜像。也是一种较为复杂的技术，但是非常好的解决应用程序和系统的依赖问题。一般我们可以直接使用这个镜像来启动一个容器，而在现实中我们也是这么做的，把我们要运行的应用程序和运行的环境打包成为一个镜像，直接部署到集群的机器上面。并且可以指定该运行容器使用的资源（CPU，内存等）。以这种方式运行的程序和其它程序是相对隔离的。

容器方式的开发部署是具非常高的可移植性，用户可以轻松地在开发测试、预发布或生产环境中运行相同的容器。如果应用程序被设计为支持水平扩缩容，就可以根据当前业务的负载情况启动或停止容器的多个实例。

Docker 项目是当前最受欢迎的容器实现，以至于很多人通常都将 Docker和容器互换使用，但 Docker 项目只是容器技术的一种实现，还有现在的 k8s 中已经在使用 containerd 替换 Docker。现在是说的容器的内核实现是基于 Cgroup 和内核的 namespace 等技术实现的，而且目前是有标准的容器运行接口： CRI。Docker 和 containerd 都是实现了容器运行接口来启动管理容器的。

因为具备轻量级的隔离属性，容器技术已然成为云原生时代应用程序开发、部署和运维的标准基础设置。目前全球的云厂商都是支持容器部署方式，而且是主流方式。总结来看使用容器技术开发和部署应用程序的如下好处。

1. 容器的轻量带来了容器本身创建和启动速度非常快捷，而且管理成本和稳定性更好。以此带来了开发的效率提升。
2. 因为标准化，所以可以很好的实现自动化，很容易做到 CICDCO。
3. 目前部署都是使用镜像部署（下面会详细说），容器的创建和启动都是依赖于统一的源头，所以在较高的程度上保证了部署各个环境各个部署的一致性。
4. 可移植性：标准化的容器镜像可以保证应用程序运行于 Ubuntu、CentOS 等各种操作系统，在不同厂商的云环境下也可以轻松的跑起来。
5. 实现了资源隔离：容器应用程序和主机之间的隔离、容器应用程序之间的隔离可以为运行应用程序提供一定的安全保证。

容器技术大大简化了应用程序的分发和部署，可以说容器技术是云原生应用发展的基础。

### 容器编排技术
有了容器技术做应用程序的分发和部署就万事大吉了吗？还有没有其它的问题？答案是显而易见的，首先带来的问题就是容器的管理问题。上面我们说的 Docker 只能解决单个机器内多个容器的管理问题，而且还相对比较粗糙。现实世界中我们是以集群为单位来管理的，一个集群上前台机器是非常常见的，而且还有上万台机器的。那么这种情况下我们怎么管理这么多机器上的容器呢？

所以容器的编排技术应运而生，从容器诞生起就有在做这方面的工作了，主要的有 Mesos，Swarm，Kuberneters，另外还有其它小型的就更多了。

![](imgs/3.png)

Kubernetes 源自Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。从 Mesos，Swarm，Kuberneters 三个开始争夺天下，到最后 Kuberneters 一统天下也就不过 3 年时间。目前 Kuberneters 是事实上的主流容器编排引擎。

Kuberneters 的架构非常简单清晰，但是功能也确实非常强调，这里可以看看它的基本架构。

![](imgs/5.png)

## 云原生交付部署：不可变基础设施
### 镜像
Build, Ship, and Run Any App, Anywhere 
![](imgs/6.png)

### 不可变基础设施
在应用开发测试到上线的过程中，应用通常需要被频繁部署到开发环境、测试环境和生产环境中，在传统的可变架构时代，通常需要系统管理员保证所有环境的一致性，而随着时间的推移，这种靠人工维护的环境一致性很难维持，环境的不一致又会导致应用越来越容易出错。这种由人工维护、经常被更改的环境就是我们常说的“可变基础设施”。

![](imgs/7.png)

与可变基础设施相对应的是不可变基础设施，是指一个基础设施环境被创建以后不接受任何方式的更新和修改。这个基础设施也可以作为模板来扩展更多的基础设施。

如果需要对基础设施做更新迭代，那么应该先修改这些基础设施的公共配置部分，构建新的基础设施，将旧的替换下线。简而言之，不可变基础设施架构是通过整体替换而不是部分修改来创建和变更的。

![](imgs/8.png)

不可变基础设施的优势在于能保持多套基础设施的一致性和可靠性，而且基础设施的创建和部署过程也是可预测的。在云原生结构中，借助Kubernetes和容器技术，云原生不可变基础设施提供了一个全新的方式来实现应用交付。云原生不可变基础设施具有以下优势。

能提升应用交付效率：基于不可变基础设施的应用交付，可以由代码或编排模板来设定，这样就可以使用Git等控制工具来管理应用和维护环境。基础设施环境一致性能保证应用在开发测试环境、预发布环境和线上生产环境的运行表现一致，不会频繁出现开发测试时运行正常、发布后出现故障的情况。
能快速、可靠地水平扩展：基于不可变基础设施的配置模板，我们可以快速创建与已有基础设施环境一致的新基础设施环境。
能保证基础设施的快速更新和回滚：基于同一套基础设施模板，若某一环境被修改，则可以快速进行回滚和恢复，若需对所有环境进行更新升级，则只需更新基础设施模板并创建新环境，将旧环境一一替换。


<center>
看完本文有收获？请分享给更多人

关注「黑光技术」，关注大数据+微服务

![](/img/qrcode_helight_tech.jpg)

</center>