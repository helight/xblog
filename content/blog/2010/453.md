+++
title = "Gdb+core调试技术"
date = "2010-09-15T02:28:03+08:00"
tags = ["python"]
categories = ["kernel"]
banner = "img/banners/banner-2.jpg"
draft = false
author = "helight"
authorlink = "https://helight.cn"
summary = ""
keywords = ["python"]
+++

做c方面的开发，免不了要是用gdb来调试程序，最近也是在公司做的时候时常需要使用gdb来分析程序，使用最多的当属使用core来查看程序运行的crash原因。

在linux中应用程序运行奔溃之后一般会产生core文件，core文件是core dump来产生，core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中。
<!--more-->
要生成core dump文件，首先要在系统中设置core文件大小的上限，超过这个上限的core文件就不生成了，而一般系统的设置是0，即不生成core文件，所以要先修改这个上限值，设置如下：

## 系统设置
使用ulimit -a命令查看系统所有限制情况，
```c
helight@zhwen:~> ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
file size               (blocks, -f) unlimited
pending signals                 (-i) 3583
max locked memory       (kbytes, -l) 32
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3583
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
helight@zhwen:~>
```
使用ulimit -c ***来设置core文件大小的上限。一般使用ulimit -c unlimited即不限制core文件大小。
```c
helight@zhwen:~> ulimit -c unlimited
helight@zhwen:~> ulimit -a
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
file size               (blocks, -f) unlimited
pending signals                 (-i) 3583
max locked memory       (kbytes, -l) 32
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3583
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
helight@zhwen:~>
```
## 编译程序
当然另外一个就是要是用来调试程序，那编译的时候加入参数就是必不可少的，下面是我在调试一个线程程序时的情况：
```c
helight@zhwen:~/test> g++ -g test.cpp -o test -lpthread
helight@zhwen:~/test> ./test
This is the main process.
This is the main process.
This is the main process.
This is a pthread.
This is a pthread.
This is a pthread.
Segmentation fault (core dumped)
helight@zhwen:~/test> ls
core.314  test  test.cpp
helight@zhwen:~/test>
```
## 使用调试：
```c
helight@zhwen:~/test> gdb ./test ./core.314
GNU gdb (GDB) SUSE (6.8.50.20090302-1.5.18)
....
```
启动调试可以使用where或者bt（breaktrace）来查看错误发生的位置和堆栈。
```c
...
Core was generated by `./test'.
Program terminated with signal 11, Segmentation fault.
#0  0x080486bd in xthread (args=0x0) at test.cpp:17
17              printf("yyyyyyyyy%ld \n",*xy);
(gdb) bt
#0  0x080486bd in xthread (args=0x0) at test.cpp:17
#1  0xb7ee535b in start_thread () from /lib/libpthread.so.0
#2  0xb7d5dc0e in clone () from /lib/libc.so.6
(gdb)
```
在gdb的调试中还可以使用一下的一些命令来辅助调试：

search  fun_name 查找函数

b fun_name在这个函数处设置断点

b file.c 114 在file.c这个文件的114行设置断点

info break或者info b来查看当前设置断点的情况

run 运行程序

file 加载二进制文件

n执行下一语句

s单步执行

c继续运行

p name 打印变量

q退出

<center>
看完本文有收获？请分享给更多人<br>

关注「黑光技术」，关注大数据+微服务<br>

![](/img/qrcode_helight_tech.jpg)
</center>
